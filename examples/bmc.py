"""Module providing bounded model checking for graph reconfiguration."""
import re
import sys

from collections.abc import Callable
from functools import reduce

from pygplib import NameMgr, Fog
from pygplib import op


class TplCnfParam:
    """Collection of parameters, used when CNF is generated.

    CNF is generated by coping "template CNF" with variables changed.
    Here, template CNF is a CNF which is independent of actual state.
    CNF of each state can be computed by replacing variable indices of
    templace CNF with those in each state.

    NOTE:
        The parameters, target_base and target_total, are not set in
        the initialization time of this object,
        which have to be determined each time CNF is generated.
    """

    def __init__(
        self,
        tpl_base: int = 0,
        tpl_aux_size: int = 0,
        template_cnf: tuple[tuple[int, ...], ...] = None,
        target_base: int = 0,
        target_total: int = 0,
        is_copied: bool = True,
    ):
        """Initializes TplCnfParam objects."""
        self._tpl_base = tpl_base
        """Index of aux vars in template cnf, starting from this number plus 1.
        (all non-aux vars are smaller than this number)"""
        self._tpl_aux_size = tpl_aux_size
        """Number of aux vars (introduced during encoding) in tempalte cnf"""
        self._template_cnf = template_cnf
        """Template CNF computed in advance"""
        self._target_base = target_base
        """Aux base, used when CNF is generated with template CNF"""
        self._target_total = target_total
        """Total number of aux vars, used when CNF is generated"""
        self._is_copied = is_copied
        """Is template need to be cpied?"""

    def get_tpl_base(self) -> int:
        """Gets tpl_base."""
        return self._tpl_base

    def get_tpl_aux_size(self) -> int:
        """Gets tpl_aux_size."""
        return self._tpl_aux_size

    def get_template_cnf(self) -> tuple[tuple[int, ...], ...]:
        """Gets template_cnf."""
        return self._template_cnf

    def get_target_base(self) -> int:
        """Gets target_base."""
        return self._target_base

    def get_target_total(self) -> int:
        """Gets target_total."""
        return self._target_total

    def set_tpl_base(self, tpl_base: int) -> None:
        """Sets tpl_base."""
        self._tpl_base = tpl_base

    def set_tpl_aux_size(self, tpl_aux_size: int) -> None:
        """Sets tpl_aux_size."""
        self._tpl_aux_size = tpl_aux_size

    def set_template_cnf(self, template_cnf: tuple[tuple[int, ...], ...]) -> None:
        """Sets template_cnf."""
        self._template_cnf = template_cnf

    def set_target_base(self, target_base) -> None:
        """Sets target_base."""
        self._target_base = target_base

    def set_target_total(self, target_total) -> None:
        """Sets target_total."""
        self._target_total = target_total

    def is_copied(self) -> bool:
        """Decides whether template CNF is copied."""
        return self._is_copied


class Bmc:
    """Bounded model checking for graph reconfiguration problem.

    Bmc object is initialized with a collection of first-order formulas,
    with which a graph reconfiguration problem instance is defined.
    It is able to compute CNF for the bounded version of that instance
    and to write it down in DIMACS CNF format.
    It is also able to decode truth assignment of variables in DIMACS CNF
    into that of propotional variables, which have correspondence to
    first-order variables and hence can be decoded further into assignment
    of first-order variables using graph structure of Fog class.
    """

    def __init__(
        self,
        state_expr: Fog,
        trans_expr: Fog,
        ini_expr: Fog,
        fin_expr: Fog,
        prefix: str = "nx_",
        trans_type: str = "None",
    ):
        """Initializes BMC object.

        Args:
            state_expr: first-order formula of state property
            trans_expr: first-order formula of transition relation
                (possibly None)
            ini_expr: first-order formula of init state (or list of integers)
            fin_expr: first-order formula of final state (or list of integers)
            prefix: with which name of next state variable begins.
            trans_type: built-in transition relation type (optional).
                Set either TJ (token jumping) or TS (token sliding)
                to trans_type (and set None to trans_expr).
        """
        if Fog.st is None:
            raise Exception("Set graph structure of Fog class")
        if state_expr is None:
            raise Exception("Set state expression")
        if ini_expr is None:
            raise Exception("Set initial state expression")
        if fin_expr is None:
            raise Exception("Set final state expression")


        self._curr_vars = op.get_free_vars(state_expr)
        """variables in current state, ordered based on names"""
        self._curr_vars = type(self)._sort_vars(self._curr_vars)
        self._nof_free_vars = len(self._curr_vars)
        """number of free variables in current state"""

        type(self)._check_variable_names_in_expr(state_expr, \
            trans_expr, prefix)
        type(self)._check_variable_names_in_ini_fin_expr(self._curr_vars, \
            ini_expr, fin_expr)

        # Determine correspondence of variables in current state and next state
        nvars = []  # variables in next state
        self._varloc = {}
        """variable location"""
        for pos in range(self._nof_free_vars):
            v = self._curr_vars[pos]
            # If trans expression is not given, new name is added.
            next_name = prefix + NameMgr.lookup_name(v)
            w = NameMgr.lookup_index(next_name)
            nvars.append(w)
            self._varloc[v] = pos
            self._varloc[w] = pos
        self._next_vars = tuple(nvars)
        """variables in next state"""

        # Set default transition relation if necessary
        if trans_expr is None:
            if trans_type == "TJ":
                trans_expr = type(self)._compute_tj_template(
                    self._curr_vars, self._next_vars
                )
            elif trans_type == "TS":
                trans_expr = type(self)._compute_ts_template(
                    self._curr_vars, self._next_vars
                )
            else:
                raise Exception(f"trans_type={trans_type} is undefined")

        self._prop_ini = op.propnize(ini_expr)
        """propositional formula of initial state"""
        self._prop_fin = op.propnize(fin_expr)
        """propositional formula of final state"""
        self._prop_state = op.propnize(state_expr)
        """propositional formula of each state"""
        self._prop_trans = op.propnize(trans_expr)
        """propositional formula of transition relations of adjacent states"""

        self._state_size = self._nof_free_vars * Fog.st.code_length
        """number of cnf variables in each state"""

        # Template CNF for state property is computed in advance.
        # CNF of each state will be instantiated
        # by changing variable indices of this template.
        expr_tup = (self._prop_state,) \
            + tuple([Fog.st.compute_domain_constraint(v) \
                        for v in op.get_free_vars(state_expr)])
        base, naux, template_cnf = op.compute_cnf(expr_tup)
        # NOTE: the parameters, target_base and target_total, are not yet set,
        # which have to be determined each time cnf is generated.
        self._state_param = TplCnfParam(
            tpl_base=base, tpl_aux_size=naux, template_cnf=template_cnf, is_copied=True
        )
        """parameters used when cnf of state property is generated"""

        # Template CNF for transition relation,
        # used in the same way as state property.
        expr_tup = (self._prop_trans,)
        base, naux, template_cnf = op.compute_cnf(expr_tup)
        # NOTE: the parameters, target_base and target_total, are not yet set,
        # which have to be determined each time cnf is generated.
        self._trans_param = TplCnfParam(
            tpl_base=base, tpl_aux_size=naux, template_cnf=template_cnf, is_copied=True
        )
        """parameters used when cnf of transition relation is generated"""

        self._total_state_size = 0  # determined in CNF generation
        self._trans_aux_base = 0  # determined in CNF generation

        self.nvar = 0
        """number of variables in cnf"""
        self.cnf = None
        """cnf"""

    @staticmethod
    def _sort_vars(tup: tuple) -> tuple:
        """Sorts variable indices based on their names."""
        names = [NameMgr.lookup_name(i) for i in tup]
        sorted_names = sorted(names)
        res = [NameMgr.lookup_index(s) for s in sorted_names]
        return tuple(res)

    @staticmethod
    def _compute_tj_template(curr_vars, next_vars) -> Fog:
        """Returns first-order formula of Token Jumping."""
        terms = []
        for i, v in enumerate(curr_vars):
            lits = [Fog.neg(Fog.eq(v, w)) for w in next_vars] + [
                Fog.eq(curr_vars[j], w) for j, w in enumerate(next_vars) if i != j
            ]
            res = reduce(Fog.land, lits, Fog.true_const())
            terms.append(res)
        return reduce(Fog.lor, terms, Fog.false_const())

    @staticmethod
    def _compute_ts_template(curr_vars, next_vars) -> Fog:
        """Returns first-order formula of Token Sliding."""
        terms = []
        for i, v in enumerate(curr_vars):
            lits = (
                [Fog.edg(v, next_vars[i])]
                + [Fog.neg(Fog.eq(v, w)) for w in next_vars]
                + [Fog.eq(curr_vars[j], w) for j, w in enumerate(next_vars) if i != j]
            )
            res = reduce(Fog.land, lits, Fog.true_const())
            terms.append(res)
        return reduce(Fog.lor, terms, Fog.false_const())

    @staticmethod
    def _generate_cnf_at_time(
        result_cnf: list[tuple],
        time: int,
        encode_func: Callable[[int, int, TplCnfParam], int],
        param: TplCnfParam,
    ) -> None:
        """Generates CNF of specified time."""
        for clause in param.get_template_cnf():
            new_clause = []
            for lit in clause:
                new_lit = encode_func(lit, time, param)
                new_clause.append(new_lit)
            result_cnf.append(tuple(new_clause))

    def generate_cnf(
        self, bound: int, ini_expr: Fog = None, fin_expr: Fog = None
    ) -> None:
        """Generates CNF."""
        if bound < 0:
            raise ValueError("bound must be larger than or equal to 0")

        type(self)._check_variable_names_in_ini_fin_expr(
            self._curr_vars, ini_expr, fin_expr
        )
        if ini_expr is not None:
            self._prop_ini = op.propnize(ini_expr)

        if fin_expr is not None:
            self._prop_fin = op.propnize(fin_expr)

        self._total_state_size = self._state_size * (bound + 1)
        self.nvar = self._total_state_size

        # CNF-Encoding of state properties
        self._state_param.set_target_base(self._total_state_size)
        self._state_param.set_target_total(
            self._state_param.get_tpl_aux_size() * (bound + 1)
        )

        fin_cnf = []
        for time in range(bound + 1):
            type(self)._generate_cnf_at_time(
                fin_cnf, time, self._encode_state_func, self._state_param
            )
        self.nvar += self._state_param.get_target_total()

        # CNF-Encoding of transition properties
        if 0 < bound:

            self._trans_param.set_target_base(
                self._total_state_size + self._state_param.get_target_total()
            )
            self._trans_param.set_target_total(
                self._trans_param.get_tpl_aux_size() * bound
            )

            for time in range(bound):
                type(self)._generate_cnf_at_time(
                    fin_cnf, time, self._encode_trans_func, self._trans_param
                )
            self.nvar += self._trans_param.get_target_total()
        else:
            self._trans_param.set_target_base(
                self._total_state_size + self._state_param.get_target_total()
            )
            self._trans_param.set_target_total(0)
            self._trans_aux_base = (
                self._total_state_size + self._state_param.get_target_total()
            )

        # CNF-Encoding of init state property (state property at time 0)
        base, naux, template_cnf = op.compute_cnf((self._prop_ini,))
        _ini_param = TplCnfParam(
            tpl_base=base,
            tpl_aux_size=naux,
            template_cnf=template_cnf,
            target_base=self._total_state_size
            + self._state_param.get_target_total()
            + self._trans_param.get_target_total(),
            target_total=naux,
            is_copied=False,
        )

        self._generate_cnf_at_time(fin_cnf, 0, self._encode_state_func, _ini_param)
        self.nvar += _ini_param.get_target_total()

        # CNF-Encoding of final state property
        base, naux, template_cnf = op.compute_cnf((self._prop_fin,))
        _fin_param = TplCnfParam(
            tpl_base=base,
            tpl_aux_size=naux,
            template_cnf=template_cnf,
            target_base=self._total_state_size
            + self._state_param.get_target_total()
            + self._trans_param.get_target_total()
            + _ini_param.get_target_total(),
            target_total=naux,
            is_copied=False,
        )

        self._generate_cnf_at_time(fin_cnf, bound, self._encode_state_func, _fin_param)
        self.nvar += _fin_param.get_target_total()

        self.cnf = tuple(fin_cnf)

    def _encode_state_func(self, lit: int, time: int, param: TplCnfParam) -> int:
        """Encodes template literal (of state property) and time
        into CNF literal.

        Args:
            lit: literal in template CNF of state property
            time: time of state
            param: template CNF parameters
        """
        var = abs(lit)

        tpl_base = param.get_tpl_base()
        tpl_aux_size = param.get_tpl_aux_size()
        target_base = param.get_target_base()
        target_total = param.get_target_total()

        if not 0 < var <= tpl_base + tpl_aux_size:
            raise IndexError

        if var > tpl_base:  # var is aux
            new_var = (var - tpl_base) + target_base
            if param.is_copied():
                new_var += tpl_aux_size * time
            assert target_base < new_var <= target_base + target_total, (
                f"target_base={target_base}, new_var={new_var}"
                + "target_base+target_total={target_base+target_total}"
            )
            return new_var if lit > 0 else -new_var

        else:
            symbol_index = Fog.st.get_symbol_index(var)
            assert symbol_index in self._varloc

            new_var = (
                self._varloc[symbol_index] * Fog.st.code_length
                + Fog.st.get_code_pos(var)
                + 1
            )
            assert new_var <= self._state_size

            new_var += self._state_size * time
            assert 0 < new_var <= self._total_state_size

            return new_var if lit > 0 else -new_var

    def _encode_trans_func(self, lit: int, time: int, param: TplCnfParam) -> int:
        """Encodes template literal (of transition relation) and time
        into CNF literal.

        Args:
            lit: literal in template CNF of transition relation
            time: time of state
            param: template CNF parameters
        """
        var = abs(lit)

        tpl_base = param.get_tpl_base()
        tpl_aux_size = param.get_tpl_aux_size()
        target_base = param.get_target_base()
        target_total = param.get_target_total()

        if not 0 < var <= tpl_aux_size + tpl_base:
            raise IndexError

        if var > tpl_base:  # i is aux var
            new_var = (var - tpl_base) + target_base
            if param.is_copied():
                new_var += tpl_aux_size * time
            assert target_base < new_var <= target_base + target_total
            return new_var if lit > 0 else -new_var

        else:
            symbol_index = Fog.st.get_symbol_index(var)
            assert symbol_index in self._varloc

            if self._curr_vars[self._varloc[symbol_index]] == symbol_index:
                return self._encode_state_func(lit, time, self._state_param)
            else:
                assert symbol_index in self._next_vars
                prev_symbol_index = self._curr_vars[self._varloc[symbol_index]]

                pos = Fog.st.get_code_pos(var)
                prev_prop_var = Fog.st.get_boolean_var(prev_symbol_index, pos)

                new_var = self._encode_state_func(
                    prev_prop_var, time + 1, self._state_param
                )
                assert 0 < new_var <= self._total_state_size

                new_lit = new_var if lit > 0 else -new_var
                return new_lit

    def write_cnf(self, stream=None, dimacs: bool = True) -> None:
        """Writes CNF in DIMACS CNF format.

        Args:
            stream: stdout if not specified
        """
        if self.cnf is None:
            raise Exception("Generate CNF before writting")

        if dimacs is False:
            raise Exception

        if stream is None:
            stream = sys.stdout

        out = ""
        out += f"p cnf {self.nvar} {len(self.cnf)}\n"
        for clause in self.cnf:
            out += " ".join(map(str, clause)) + " 0\n"

        if stream is not None:
            stream.write(out)

    def _decode_time(self, cnf_lit: int) -> int:
        """Decodes cnf literal into time."""
        cnf_var = abs(cnf_lit)
        if cnf_var > self._total_state_size:
            raise ValueError("Cannot decode cnf literal of aux variable")

        time = int((cnf_var - 1) / self._state_size)
        return time

    def _decode_symbol_index(self, cnf_lit: int) -> int:
        """Decodes cnf literal into first-order variable."""
        cnf_var = abs(cnf_lit)
        if cnf_var > self._total_state_size:
            raise ValueError("Cannot decode cnf literal of aux variable")

        var_pos = int(((cnf_var - 1) % self._state_size) / Fog.st.code_length)
        assert 0 <= var_pos < self._nof_free_vars

        return self._curr_vars[var_pos]

    def _decode_code_pos(self, cnf_lit: int) -> int:
        """Decodes cnf literal into code position."""
        cnf_var = abs(cnf_lit)
        if cnf_var > self._total_state_size:
            raise ValueError("Cannot decode cnf literal of aux variable")

        code_pos = ((cnf_var - 1) % self._state_size) % Fog.st.code_length
        assert 0 <= code_pos < Fog.st.code_length
        return code_pos

    def decode(self, assign: tuple) -> tuple:
        """Decodes truth assignment of DIMACS CNF variables.

        Args:
            assign: tuple of nonzero integers, each of which
            represents a literal of DIMACS CNF.

        Returns:
             tuple of nonzero integers, each of which represents an
             propositional literal of Prop class.
        """
        if self.cnf is None:
            raise Exception("CNF is not yet computed")

        res = {}

        for lit in assign:
            if type(lit) != int:
                raise Exception("Non integer found")
            if lit == 0:
                raise Exception("0 not allowed")
            if abs(lit) > self._total_state_size:
                continue
            time = self._decode_time(lit)
            symbol_index = self._decode_symbol_index(lit)
            pos = self._decode_code_pos(lit)
            new_var = Fog.st.get_boolean_var(symbol_index, pos)
            if time not in res:
                res[time] = []
            res[time].append(new_var if lit > 0 else -new_var)

        return tuple([tuple(res[time]) for time in sorted(res.keys())])

    # Check variable names in state and trans expression
    @staticmethod
    def _check_variable_names_in_expr(state_expr: Fog, trans_expr: Fog, prefix: str):
        """Checks variable names."""
        state_vars = op.get_free_vars(state_expr)

        # None of free variable names in state_expr start with reserved prefix.
        for i in state_vars:
            name = NameMgr.lookup_name(i)
            if re.match(f"^{prefix}", name):
                raise Exception(
                    f"Variable name {name} in state expression"
                    + " must not start with {prefix}"
                )

        if trans_expr is not None:
            state_var_names = [NameMgr.lookup_name(i) for i in state_vars]

            trans_vars = op.get_free_vars(trans_expr)

            for i in trans_vars:
                if i in state_vars:
                    continue

                name = NameMgr.lookup_name(i)
                remain = re.sub(f"^{prefix}", "", name)
                if remain not in state_var_names:
                    raise Exception(
                        f"Variable {name} must not appear" + " in trans expression"
                    )

    # Check variable names in init state and final state expressions
    @staticmethod
    def _check_variable_names_in_ini_fin_expr(
        state_vars: tuple[int], ini_expr: Fog, fin_expr: Fog
    ):
        """Checks variable names."""
        state_var_names = [NameMgr.lookup_name(i) for i in state_vars]

        # Init State Expression
        if ini_expr is not None:
            ini_vars = op.get_free_vars_and_consts(ini_expr)
            # includes not only variables but also constants
            ini_var_names = [
                NameMgr.lookup_name(i) for i in ini_vars if NameMgr.is_variable(i)
            ]
            ini_con_names = [
                NameMgr.lookup_name(i) for i in ini_vars if NameMgr.is_constant(i)
            ]
            assert len(ini_vars) == len(ini_var_names) + len(ini_con_names)

            for name in ini_var_names:
                if name not in state_var_names:
                    raise Exception(
                        f"Variable {name} must not appear " + "in init state expression"
                    )

            for name in ini_con_names:
                if NameMgr.lookup_index(name) not in Fog.st.domain:
                    raise Exception(
                        f"Cannot intepret constant {name} " + "as domain element"
                    )

        # Final State Expression
        if fin_expr is not None:
            fin_vars = op.get_free_vars_and_consts(fin_expr)
            # includes not only variables but also constants
            fin_var_names = [
                NameMgr.lookup_name(i) for i in fin_vars if NameMgr.is_variable(i)
            ]
            fin_con_names = [
                NameMgr.lookup_name(i) for i in fin_vars if NameMgr.is_constant(i)
            ]
            assert len(fin_vars) == len(fin_var_names) + len(fin_con_names)

            for name in fin_var_names:
                if name not in state_var_names:
                    raise Exception(
                        f"Variable {name} must not appear "
                        + "in final state expression"
                    )

            for name in fin_con_names:
                if NameMgr.lookup_index(name) not in Fog.st.domain:
                    raise Exception(
                        f"Cannot intepret constant {name} " + "as domain element"
                    )
